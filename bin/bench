#!/usr/bin/env python

import argparse
import re
import os
import shlex
import shutil
import sqlite3
import subprocess
import tempfile
import time
import yaml
from collections import defaultdict


class Bench:
    def __init__(self, impl, source):
        self.impl = impl
        self.source = source

    def execute(self, cmd):
        start_time = time.time()
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        _, rc, ru = os.wait4(process.pid, 0)
        end_time = time.time()
        wall_time = end_time - start_time
        return rc, ru, wall_time

    def bench(self):
        game_vars = defaultdict(lambda: '')
        for k, v in self.source.vars.iteritems():
            game_vars[k] = v
        tmpdir = tempfile.mkdtemp()
        game_vars['executable'] = self.impl.executable
        game_vars['source'] = self.source.source
        output_file = '%s-%s' % (self.impl.name, self.source.game.nicename)
        game_vars['output'] = os.path.join(tmpdir, output_file)
        self.build(game_vars)
        self.run(game_vars)
        if os.path.exists(game_vars['output']):
            os.remove(game_vars['output'])
        os.rmdir(tmpdir)

    def build(self, game_vars):
        # Copy the source file to the output file. This will probably put the
        # file into the cache, but that is not the (primary) goal. The point is
        # to put the file that gets executed in the temporary directory.
        if not self.impl.build:
            shutil.copyfile(game_vars['source'], game_vars['output'])
            return 0, None
        cmd_s = self.impl.build % game_vars
        cmd = shlex.split(cmd_s)
        return self.execute(cmd)

    def run(self, game_vars):
        run_results = []
        for level in self.source.game.levels:
            game_vars['args'] = level['args']
            cmd_s = self.impl.run % game_vars
            cmd = shlex.split(cmd_s)
            run_results.append(self.execute(cmd))
        return run_results

class BenchResults:
    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.check_db()

    def check_db(self):
        """
        Check the database to ensure it has the right tables and the tables
        have the right columns.
        """
        # Using an ORM would obviate much of this but I want to keep this
        # lightweight and hopefully simple.
        c = self.conn.cursor()
        table_schema = {
            'run': {
                'columns': ['id', 'when', 'impl', 'version'],
                'schema': """CREATE TABLE run (
                    id INTEGER PRIMARY KEY,
                    run_when TEXT,
                    impl TEXT,
                    version TEXT
                )""",
            },
            'results': {
                'columns': ['run_id', 'result', 'args', 'level', 'output',
                            'cputime', 'walltime', 'memusage'],
                'schema': """CREATE TABLE results (
                    run_id INTEGER PRIMARY KEY,
                    result INTEGER,
                    args TEXT,
                    level TEXT,
                    output TEXT,
                    cputime REAL,
                    walltime REAL,
                    memusage INTEGER
                )""",
            },
        }
        for table in table_schema:
            try:
                c.execute("SELECT * FROM " + table)
            except sqlite3.OperationalError as exc:
                if exc.message.startswith('no such table:'):
                    c.execute(table_schema[table]['schema'])
                    self.conn.commit()

    def add_run(self):
        pass

    def add_result(self, run_id):
        pass

class Game:
    def __init__(self, game_name, game):
        self.name = game_name
        self.yaml_config = game
        self.description = None
        self.levels = None
        self.nicename = None
        self.load()

    def load(self):
        self.description = self.yaml_config['description']
        self.levels = self.yaml_config['levels']
        self.nicename = self.yaml_config.get('nicename', self.name)

class GameSource:
    def __init__(self, source_file):
        self.source = source_file
        self.game = None
        self.lang = set()
        self.vars = {}
        self.load()

    def load(self):
        # To allow embedding the meta data in the source file, this requires a
        # consistent pattern to detect it. There must be zero or more white
        # space characters to start the line, followed by one or more non-white
        # space characters (e.g. the comment character(s)), followed by zero or
        # more white space character. Then each meta data variable takes the
        # form NAME=VALUE. White space will be trimmed from the beginning and
        # end of both NAME and VALUE.
        def escape_meta(string):
            metachars = {'.': r'\.', '*': r'\*', '+': r'\+'}
            esc = [metachars.get(s, s) for s in string]
            return ''.join(esc)

        def make_var_re(comment_string=None, name=None):
            # Some metacharacters that probably will show up and need to be escaped.
            regex_str = r'^\s*(%s)\s*(%s)=(.*)$'
            if comment_string is None:
                comment_string = r'\S+'
            else:
                comment_string = escape_meta(comment_string)
            if name is None:
                name = r'\w+'
            else:
                name = escape_meta(name)
            regex = regex_str % (comment_string, name)
            return re.compile(regex, re.MULTILINE)

        with open(self.source) as f:
            contents = f.read()

        name_re = make_var_re(name='GAME')
        name_var = name_re.search(contents)
        if not name_var:
            return
        # Found something matching GAME=foo. Get the comment string at the
        # beginning to find the rest of the meta data. The game name is not
        # saved to make logic in the loop simpler.
        name_groups = name_var.groups()
        comment_string = name_groups[0]
        meta_data = make_var_re(comment_string=comment_string).findall(contents)
        for meta in meta_data:
            _, option, value = meta
            if option == 'LANG':
                if isinstance(value, basestring):
                    self.lang.add(value)
                else:
                    self.lang.update(value)
            else:
                self.vars[option] = value

    def is_valid(self):
        return 'GAME' in self.vars

class Impl:
    def __init__(self, impl_name, impl):
        self.name = impl_name
        self.yaml_config = impl
        self.executable = None
        self.impl = None
        self.run = None
        self.version = None
        self.build = None
        self.load()

    def load(self):
        self.executable = self.yaml_config['executable']
        self.impl = self.yaml_config['impl']
        self.run = self.yaml_config['run']
        self.version = self.yaml_config['version']
        self.build = self.yaml_config.get('build')

def load_all_games(cfg_yml):
    games = {}
    for game_name, game in cfg_yml['game'].iteritems():
        g = Game(game_name, game)
        nicename = g.nicename
        games[nicename] = g
    return games

def load_all_impls(cfg_yml):
    impls = {}
    for impl_name, impl in cfg_yml['impl'].iteritems():
        i = Impl(impl_name, impl)
        impls[impl_name] = i
    return impls

def load_all_sources(game_dir, games):
    sources = defaultdict(lambda: [])
    for root, dirs, files in os.walk(game_dir):
        if '.git' in dirs:
            dirs.remove('.git')
        for f in files:
            g = GameSource(os.path.join(root, f))
            if g.is_valid():
                if g.vars['GAME'] in games:
                    g.game = games[g.vars['GAME']]
                    sources[g.vars['GAME']].append(g)
    return sources

def get_options():
    parser = argparse.ArgumentParser(description="The implementation game")
    parser.add_argument("--config-file", metavar='FILE',
                        help="YAML file containing all implementations.")
    parser.add_argument("--database", "-d", metavar="DB",
                        help="Output database to save results.")
    parser.add_argument("--game", "-g",
                        help="Accepts a comma-separated list of games to run."
                        " Two special arguments are accepted:"
                        " 'list' to list all games and"
                        " 'all' to run everything."
                        " The default is 'all'.",
                        default="all")
    parser.add_argument("--game-dir",
                        help="Directory containing source for the games.")
    parser.add_argument("--impl", "-i",
                        help="Accepts a comma-separated list of implementations to run."
                        " Two special arguments are accepted:"
                        " 'list' to list all implementations and"
                        " 'all' to run everything."
                        " The default is 'all'.",
                        default="all")
    return parser.parse_args()

def main():
    args = get_options()
    cwd = os.getcwd()

    if args.config_file is None:
        config_file = os.path.join(cwd, 'implgame.yml')
    else:
        config_file = args.config_file

    if args.game_dir is None:
        game_dir = os.path.join(cwd, 'game')
    else:
        game_dir = args.game_dir

    with open(config_file, 'r') as cf:
        config_file_yml = yaml.safe_load(cf)
    impls = load_all_impls(config_file_yml)
    games = load_all_games(config_file_yml)
    sources = load_all_sources(game_dir, games)

    if args.game == 'list':
        print "Found games: %s" % (", ".join(sorted(games.keys())))
        return
    if args.impl == 'list':
        print "Found implementations: %s" % (", ".join(sorted(impls.keys())))
        return

    # TODO: Clean this up so args.game and args.impl are used.
    for s in sources:
        for source in sources[s]:
            for implname, impl in impls.iteritems():
                if impl.impl not in source.lang:
                    continue
                b = Bench(impl, source)
                b.bench()


if __name__ == '__main__':
    main()
