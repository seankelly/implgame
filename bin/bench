#!/usr/bin/env python

import argparse
import re
import os
import shlex
import shutil
import subprocess
import tempfile
import time
import yaml
from collections import defaultdict
from glob import glob


class Bench:
    def __init__(self, impl, source):
        self.impl = impl
        self.source = source

    def bench(self):
        vars = defaultdict(lambda: '')
        for k, v in self.source.vars.iteritems():
            vars[k] = v
        tmpdir = tempfile.mkdtemp()
        vars['executable'] = self.impl.executable
        vars['source'] = self.source.source
        output_file = '%s-%s' % (self.impl.name, self.source.game.nicename)
        vars['output'] = os.path.join(tmpdir, output_file)
        self.build(vars)
        self.run(vars)
        if os.path.exists(vars['output']):
            os.remove(vars['output'])
        os.rmdir(tmpdir)

    def build(self, vars):
        # Copy the source file to the output file. This will probably put the
        # file into the cache, but that is not the (primary) goal. The point is
        # to put the file that gets executed in the temporary directory.
        if not self.impl.build:
            shutil.copyfile(vars['source'], vars['output'])
            return
        cmd_s = self.impl.build % vars
        cmd = shlex.split(cmd_s)
        subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    def run(self, vars):
        pass

class Game:
    def __init__(self, game_name, game):
        self.name = game_name
        self.yaml_config = game
        self.load()

    def load(self):
        self.description = self.yaml_config['description']
        self.levels = self.yaml_config['levels']
        self.nicename = self.yaml_config.get('nicename', self.name)

class GameSource:
    def __init__(self, source_file):
        self.source = source_file
        self.game = None
        self.lang = set()
        self.vars = {}
        self.load()

    def load(self):
        # To allow embedding the meta data in the source file, this requires a
        # consistent pattern to detect it. There must be zero or more white
        # space characters to start the line, followed by one or more non-white
        # space characters (e.g. the comment character(s)), followed by zero or
        # more white space character. Then each meta data variable takes the
        # form NAME=VALUE. White space will be trimmed from the beginning and
        # end of both NAME and VALUE.
        def escape_meta(str):
            metachars = set(['.', '*', '+'])
            esc = map(lambda s: s if s not in metachars else "\\" + s, str)
            return ''.join(esc)

        def make_var_re(comment_string=None, name=None):
            # Some metacharacters that probably will show up and need to be escaped.
            regex_str = '^\s*(%s)\s*(%s)=(.*)$'
            if comment_string is None:
                comment_string = '\S+'
            else:
                comment_string = escape_meta(comment_string)
            if name is None:
                name = '\w+'
            else:
                name = escape_meta(name)
            regex = regex_str % (comment_string, name)
            return re.compile(regex, re.MULTILINE)

        with open(self.source) as f:
            contents = f.read()

        name_re = make_var_re(name='GAME')
        name_var = name_re.search(contents)
        if not name_var:
            return
        # Found something matching GAME=foo. Get the comment string at the
        # beginning to find the rest of the meta data. The game name is not
        # saved to make logic in the loop simpler.
        name_groups = name_var.groups()
        comment_string = name_groups[0]
        meta_data = make_var_re(comment_string=comment_string).findall(contents)
        for meta in meta_data:
            _, option, value = meta
            if option == 'LANG':
                if isinstance(value, basestring):
                    self.lang.add(value)
                else:
                    self.lang.update(value)
            else:
                self.vars[option] = value

    def is_valid(self):
        return ('GAME' in self.vars)

class Impl:
    def __init__(self, impl_name, impl):
        self.name = impl_name
        self.yaml_config = impl
        self.load()

    def load(self):
        self.executable = self.yaml_config['executable']
        self.impl = self.yaml_config['impl']
        self.run = self.yaml_config['run']
        self.version = self.yaml_config['version']
        self.build = self.yaml_config.get('build')

def load_all_games(cfg_yml):
    games = {}
    for game_name, game in cfg_yml['game'].iteritems():
        g = Game(game_name, game)
        nicename = g.nicename
        games[nicename] = g
    return games

def load_all_impls(cfg_yml):
    impls = {}
    for impl_name, impl in cfg_yml['impl'].iteritems():
        i = Impl(impl_name, impl)
        impls[impl_name] = i
    return impls

def load_all_sources(game_dir, games):
    sources = defaultdict(lambda: [])
    for root, dirs, files in os.walk(game_dir):
        if '.git' in dirs:
            dirs.remove('.git')
        for f in files:
            g = GameSource(os.path.join(root, f))
            if g.is_valid():
                if g.vars['GAME'] in games:
                    g.game = games[g.vars['GAME']]
                    sources[g.vars['GAME']].append(g)
    return sources

def get_options():
    parser = argparse.ArgumentParser(description="The implementation game")
    parser.add_argument("--config-file", metavar='FILE',
                        help="YAML file containing all implementations.")
    parser.add_argument("--database", "-d", metavar="DB",
                        help="Output database to save results.")
    parser.add_argument("--game", "-g",
                        help="Accepts a comma-separated list of games to run."
                        " Two special arguments are accepted:"
                        " 'list' to list all games and"
                        " 'all' to run everything."
                        " The default is 'all'.",
                        default="all")
    parser.add_argument("--game-dir",
                        help="Directory containing source for the games.")
    parser.add_argument("--impl", "-i",
                        help="Accepts a comma-separated list of implementations to run."
                        " Two special arguments are accepted:"
                        " 'list' to list all implementations and"
                        " 'all' to run everything."
                        " The default is 'all'.",
                        default="all")
    return parser.parse_args()

def main():
    args = get_options()
    cwd = os.getcwd()

    if args.config_file is None:
        config_file = os.path.join(cwd, 'implgame.yml')
    else:
        config_file = args.config_file

    if args.game_dir is None:
        game_dir = os.path.join(cwd, 'game')
    else:
        game_dir = args.game_dir

    with open(config_file, 'r') as cf:
        config_file_yml = yaml.safe_load(cf)
    impls = load_all_impls(config_file_yml)
    games = load_all_games(config_file_yml)
    sources = load_all_sources(game_dir, games)

    if args.game == 'list':
        print "Found games: %s" % (", ".join(sorted(games.keys())))
        return
    if args.impl == 'list':
        print "Found implementations: %s" % (", ".join(sorted(impls.keys())))
        return

    # TODO: Clean this up so args.game and args.impl are used.
    for s in sources:
        for source in sources[s]:
            for implname, impl in impls.iteritems():
                b = Bench(impl, source)
                b.bench()


if __name__ == '__main__':
    main()
